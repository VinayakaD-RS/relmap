//lit
import { LitElement, html, css } from 'lit';
import { MixinManager } from '@riversandtechnologies/ui-platform-elements/lib/managers/mixin-manager.js';
import { RufElement } from '@riversandtechnologies/ui-platform-elements/lib/base/ruf-element.js';
import { AppBase } from '@riversandtechnologies/ui-platform-elements/lib/base/app-base.js';
import ComponentConfigBase from '@riversandtechnologies/ui-platform-business-elements/lib/base/component-config-base.js';
// ui-platform-utils
import { ObjectUtils } from '@riversandtechnologies/ui-platform-utils/lib/common/ObjectUtils.js';
import { Constants } from '@riversandtechnologies/ui-platform-utils/lib/mdm/Constants.js';
import { ContextUtils } from '@riversandtechnologies/ui-platform-utils/lib/mdm/ContextUtils.js';
import { EntityUtils } from '@riversandtechnologies/ui-platform-utils/lib/mdm/EntityUtils.js';
import { AttributeUtils } from '@riversandtechnologies/ui-platform-utils/lib/mdm/AttributeUtils.js';
import { UniqueIdUtils } from '@riversandtechnologies/ui-platform-utils/lib/common/UniqueIdUtils.js';
// ui-platform-elements
import '@riversandtechnologies/ui-platform-elements/lib/elements/pebble-textbox/pebble-textbox.js';
import '@riversandtechnologies/ui-platform-elements/lib/elements/bedrock-grid/bedrock-grid.js';
import '@riversandtechnologies/ui-platform-elements/lib/elements/pebble-button/pebble-button.js';
import '@riversandtechnologies/ui-platform-elements/lib/elements/bedrock-pubsub/bedrock-pubsub.js';
import '@riversandtechnologies/ui-platform-elements/lib/elements/pebble-toggle-button/pebble-toggle-button.js';
import { BedrockGridDataSource } from '@riversandtechnologies/ui-platform-elements/lib/base/BedrockGridDataSource.js';
import { DialogManager } from '@riversandtechnologies/ui-platform-elements/lib/managers/dialog-manager.js';

// ui-platform-dataaccess
import { DataObjectManager } from '@riversandtechnologies/ui-platform-dataaccess/lib/managers/DataObjectManager.js';
import { EntityTypeManager } from '@riversandtechnologies/ui-platform-dataaccess/lib/managers/EntityTypeManager.js';
import { DALCommonUtils } from '@riversandtechnologies/ui-platform-dataaccess/lib/utils/DALCommonUtils.js';
import { EntityCompositeModelManager } from '@riversandtechnologies/ui-platform-dataaccess/lib/managers/EntityCompositeModelManager.js';
// ui-platform-business-elements
import '@riversandtechnologies/ui-platform-business-elements/lib/elements/rock-attribute/rock-attribute.js';
import '@riversandtechnologies/ui-platform-business-elements/lib/elements/rock-entity-type-model-lov/rock-entity-type-model-lov.js';
import '@riversandtechnologies/ui-platform-elements/lib/elements/pebble-spinner/pebble-spinner.js';

import DataHelper from '@riversandtechnologies/ui-platform-business-elements/lib/helpers/DataHelper.js';
import DataRequestHelper from '@riversandtechnologies/ui-platform-business-elements/lib/helpers/DataRequestHelper.js';
import DataTransformHelper from '@riversandtechnologies/ui-platform-business-elements/lib/helpers/DataTransformHelper.js';
import { EntityGridDataSource } from '@riversandtechnologies/ui-platform-business-elements/lib/managers/EntityGridDataSource.js';
// Include Styles
import { styles as sharedStyles } from '@riversandtechnologies/ui-platform-elements/lib/flow/core/base/shared.element.css.js';
import { LoggerManager } from '@riversandtechnologies/ui-platform-elements/lib/managers/logger-manager.js';

class RockDragDropGrid extends MixinManager(LitElement).with(ComponentConfigBase, RufElement, AppBase) {
    render() {
        return html` <div class="grid-wrapper" flow-layout="p:sm m-t:sm">
            <pebble-spinner .active=${this._loading}></pebble-spinner>
            <div class="base-grid-structure">
                <div class="base-grid-structure-child-1">
                    <div flow-layout="grid cols:auto gap:md">
                        <div>
                            ${!ObjectUtils.isEmpty(this._isDomainLovPrepared)
                                ? html` <bedrock-lov
                                      id="domainDropdown"
                                      .showActionButtons="${false}"
                                      .selectAll=${false}
                                      .multiSelect=${false}
                                      .filterEnabled="${true}"
                                      .items="${this._domainList}"
                                      .noLabelFloat="${true}"
                                      .noSubTitle="${true}"
                                      .label="${this.localize('DomTxt')}"
                                      .selectedItem=${this._selectedDomain}
                                      @selected-value-changed="${this._onDomainChange}"
                                      @tag-removed="${this._onDomainChange}"
                                  ></bedrock-lov>`
                                : html``}
                        </div>
                        <div>
                            ${this._isSourceLovPrepared
                                ? html` <bedrock-lov
                                      id="sourceDropdown"
                                      .showActionButtons="${false}"
                                      .selectAll=${false}
                                      .multiSelect=${false}
                                      .filterEnabled="${true}"
                                      .items="${this._sourceList}"
                                      .noLabelFloat="${true}"
                                      .noSubTitle="${true}"
                                      .label="${this.configType == 'source'
                                          ? this.localize('SrcTxt')
                                          : this.localize('TarTxt')}"
                                      .selectedItem=${this._selectedSource}
                                      @selected-value-changed="${this._onSourceChange}"
                                      @tag-removed="${this._onSourceChange}"
                                  ></bedrock-lov>`
                                : html``}
                        </div>
                        ${this.config?.showRelationshipFilter
                            ? html` <div>
                                  ${this._isRelationshipLovPrepared
                                      ? html` <bedrock-lov
                                            id="relationshipDropdown"
                                            .showActionButtons="${false}"
                                            .selectAll=${false}
                                            .multiSelect=${false}
                                            .filterEnabled="${true}"
                                            .items="${this._relationshipTypes}"
                                            .noLabelFloat="${true}"
                                            .noSubTitle="${true}"
                                            .label="${this.localize('RelTxt')}"
                                            .selectedItem=${this._selectedRelationship}
                                            @selected-value-changed="${this._onRelationshipTypeChange}"
                                            @tag-removed="${this._onRelationshipTypeChange}"
                                        ></bedrock-lov>`
                                      : html``}
                              </div>`
                            : html``}
                    </div>
                    <div class="search-bar" flow-layout="m-t:sm horizontal wrap:none">
                        <pebble-search-bar id="searchBar" placeholder="${this.localize('SeaTxt')} "></pebble-search-bar>
                        <pebble-button
                            id="searchButton"
                            class="apply btn btn-success"
                            button-text=${this.localize('SeaTxt')}
                            noink=""
                            elevation="2"
                            @click=${this._onSearch}
                        ></pebble-button>
                    </div>
                </div>
                <div class="base-grid-structure-child-2 relative">
                    ${this.config?.showMappedFilterExists
                        ? html` <div class="showMapped_wrapper">
                              <pebble-toggle-button
                                  ?checked=${this._isShowMapped}
                                  ?disabled="false"
                                  .title=${this.localize('ShoMapTxt')}
                                  @checked-changed=${this._onShowMappedChange}
                                  >${this.localize('ShoMapTxt')}</pebble-toggle-button
                              >
                          </div>`
                        : ``}
                    ${!ObjectUtils.isEmpty(this.config)
                        ? html` <bedrock-grid
                              id="${this.configType}_dragDropGrid"
                              .config="${this._gridConfig}"
                              .columns=${this._columns}
                              .actionScope=${this._actionScope}
                              .options=${this._gridOptions}
                              .showEmptyMessageWithHeaders=${this._isGridDataEmpty}
                              .emptyMessage=${this._gridInfo}
                              .editEnabled=${false}
                              .showCompactTitles=${true}
                              ?hideViewSelector=${true}
                              .resultRecordSize=${this.resultRecordSize}
                              .currentRecordSize=${this.currentRecordSize}
                              .showSelectAllCheckbox=${false}
                              .scopeId=${this.scopeId}
                          ></bedrock-grid>`
                        : ``}
                </div>
            </div>
        </div>`;
    }

    static get styles() {
        const localStyle = css`
            :host {
                --context-coalesce-label-color: #000;
                --context-coalesce-label-font-weight: 600;
            }
            .grid-wrapper {
                border: 1px solid var(--flow-global-border-color);
                height: 100%;
            }
            .leftContainer {
                width: 40%;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .rightContainer {
                width: 60%;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            pebble-button {
                margin-top: 0px;
            }
            pebble-toggle-button {
                --pebble-toggle-button-checked-bar-color: var(--success-color, #4caf50);
                --pebble-toggle-button-checked-button-color: var(--success-color, #4caf50);
                --pebble-toggle-button-checked-ink-color: var(--success-color, #4caf50);
                --pebble-toggle-button-label-font-size: var(--flow-font-size-xsm);
                --pebble-toggle-button-label-color: var(--flow-global-font-color);
            }
            .relative {
                position: relative;
            }
            .showMapped_wrapper {
                position: absolute;
                top: 15px;
                font-weight: var(--flow-font-weight-regular);
                left: 20px;
                max-width: 30%;
            }
            .ag-icon {
                font-family: var(--ag-icon-font-family);
                font-size: var(--ag-icon-size);
                line-height: var(--ag-icon-size);
                font-style: normal;
                font-weight: 400;
                font-variant: normal;
                text-transform: none;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }
        `;

        return [sharedStyles, localStyle];
    }

    static get properties() {
        return {
            config: { type: Object },
            contextData: { type: Object, attribute: false },
            configType: { type: String }, //source or target
            _loading: { type: Boolean },
            _columns: { type: Array, attribute: false },
            rowSelection: { type: String },
            options: { type: Object, attribute: false },
            _gridOptions: { type: Object, attribute: false },
            _gridConfig: { type: Object },
            _isGridDataEmpty: { type: Boolean },
            _gridInfo: { type: String },
            pageSize: { type: Number },
            batchSize: { type: Number },
            _dataIndex: { type: String },
            _actionScope: { type: Object },
            maxConfiguredCount: { type: Number },
            resultRecordSize: { type: Number },
            currentRecordSize: { type: Number },
            scopeId: { type: String },

            _isDomainLovPrepared: { type: Boolean },
            _domainList: { type: Array },
            _selectedDomain: { type: Object },

            _isSourceLovPrepared: { type: Boolean },
            _sourceList: { type: Array },
            _selectedSource: { type: Object },

            _relationshipTypes: { type: Array },
            _selectedRelationship: { type: Object },
            attributeModels: { type: Object },
            _isRelationshipLovPrepared: { type: Boolean },

            _isShowMapped: { type: Boolean },

            //Dirty check properties
            _isDirtyCheckHandled: { type: Boolean },
            _dirtyCheckEventName: { type: String },
            _previousSearchedQuery: { type: String },
            _previousSelectedDomain: { type: Object },
            _previousSelectedSource: { type: Object },
            _previousSelectedRel: { type: Object }
        };
    }

    constructor() {
        super();
        this.config = {};
        this.configType = '';
        this.contextData = {};
        this._loading = false;

        this._columns = [];
        this.rowSelection = '';
        this.options = {};
        this._gridOptions = {};
        this._gridConfig = {};
        this._isGridDataEmpty = false;
        this._gridInfo = '';
        this.pageSize = 50;
        this.batchSize = 50;
        this._actionScope = {};
        this._dataIndex = 'entityData';
        this.maxConfiguredCount = 500;
        this.resultRecordSize = 0;
        this.currentRecordSize = 0;
        this.scopeId = '';

        this._isDomainLovPrepared = false;
        this._domainList = [];
        this._selectedDomain = {};

        this._isSourceLovPrepared = false;
        this._sourceList = [];
        this._selectedSource = {};

        this._relationshipTypes = [];
        this._selectedRelationship = {};

        this.attributeModels = {};
        this._isRelationshipLovPrepared = false;

        this._isShowMapped = false;
        this._isDirtyCheckHandled = false;
        this._dirtyCheckEventName = '';
        this._previousSearchedQuery = '';
        this._previousSelectedDomain = {};
        this._previousSelectedSource = {};
        this._previousSelectedRel = {};

        this.actions = {
            'grid-toolbar-action-custom-toolbar-event': {
                name: 'grid-toolbar-action-custom-toolbar-event'
            }
        };
    }

    actionCallback(actionName, detail) {
        switch (actionName) {
            case 'grid-toolbar-action-custom-toolbar-event': {
                this._onToolbarEvent(detail);
                break;
            }
        }
    }

    // _gridSelectionChanged(e){
    //     if(e && e?.topics){
    //         const grid = e.topics[0].split('_')[1];
    //         const objectPath = e?.clonedDetail?.selectionInfo?.selectedItems[0];
    //         if(grid === 'source'){
    //             this._sourceData = objectPath;
    //         }
    //         if(grid === 'target'){
    //             this._targetPath = objectPath?.filePath;
    //         }
    //     }

    //     if(!ObjectUtils.isEmpty(this._sourceData) && !ObjectUtils.isEmpty(this._targetPath)){
    //         this.onMoveClick(this._targetPath, this._sourceData, false);
    //     }
    // }

    gridSelectionChanged() {
        const bedrockGrid = this.shadowRoot.querySelector('bedrock-grid');
        return bedrockGrid;
    }

    _onToolbarEvent(detail) {
        if (detail && detail.actionInfo) {
            switch (detail.actionInfo.name) {
                case 'saveTargetRelMapping':
                    this._onSaveGridData(detail);
                    break;

                case 'refreshSourceRelMapping': {
                    this._onRefreshSource(detail);
                    break;
                }
                case 'refreshTargetRelMapping':
                    this._onRefreshTarget(detail);
                    break;
                default:
                    break;
            }
        }
    }

    async connectedCallback() {
        super.connectedCallback();
        await this.updateComplete;
        this.scopeId = this.configType + '_dragDropGrid';
        // this.aci.subscribeToTopics({
        //     'rock-grid-selection-changed': {
        //         topics: [this.scopeId]
        //     }
        // });
    }

    disconnectedCallback() {
        super.disconnectedCallback();
    }

    get grid() {
        return this.shadowRoot.querySelector('#' + this.configType + '_dragDropGrid');
    }

    get dragDropGrid() {
        if (this.grid) {
            return this.grid.shadowRoot.querySelector('pebble-grid');
        }
        return null;
    }

    get domainLov() {
        return this.shadowRoot.querySelector('#domainDropdown');
    }

    get sourceLov() {
        return this.shadowRoot.querySelector('#sourceDropdown');
    }

    get relationshipLov() {
        return this.shadowRoot.querySelector('#relationshipDropdown');
    }

    get searchBar() {
        return this.shadowRoot.querySelector('#searchBar');
    }

    async firstUpdated() {
        super.firstUpdated();
        this._loading = true;
        //Initialize dropdown items
        if (!ObjectUtils.isEmpty(this.config)) {
            this._isShowMapped = this.config.showMappedDefaultValue;
            this.pageSize = !ObjectUtils.isEmpty(this.config.pageSize) ? this.config.pageSize : this.pageSize;
            this.batchSize = !ObjectUtils.isEmpty(this.config.batchSize) ? this.config.batchSize : this.batchSize;
            this._configuredDomains = this.config.domains;
            let domainList = _.pluck(this.config.domains, 'name');
            await this._prepareDomains(domainList, this.config.defaultDomain);
            let defaultSource = this.configType == 'source' ? this.config.defaultSource : this.config.defaultTarget;
            await this._prepareSources(defaultSource);
            if (this.config.showRelationshipFilter) {
                this._prepareRelationshipTypes(this.config.defaultRelationshipType);
            }
            this._treeTypeChanged();
            this._reloadGridConfig();
        } else {
            this._loading = false;
            LoggerManager.info('relationship mappings config not found');
        }
    }

    /**
     * Function to populate the domain dropdown
     */
    async _prepareDomains(domainList, defaultDomain) {
        if (!ObjectUtils.isEmpty(domainList)) {
            let req = DataRequestHelper.createGetModelRequest('domain');
            req.params.query.names = domainList;
            delete req.params.fields.attributes;
            delete req.params.fields.relationships;
            delete req.params.query.ids;
            req.params.fields.properties = ['_ALL'];
            req.params['sort'] = {
                properties: [
                    {
                        name: '_ASC',
                        sortType: Constants.getDataTypeConstant('string')
                    }
                ]
            };
            let url = '/data/pass-through/entitymodelservice/get';
            let domainResponse = await DataObjectManager.rest(url, req);
            if (ObjectUtils.isValidObjectPath(domainResponse, 'response.entityModels.0')) {
                let domains = [];
                let domainModels = domainResponse.response.entityModels;
                domainModels.forEach(function (item) {
                    const configuredDomainObj = _.find(
                        this._configuredDomains,
                        function (confDomain) {
                            return confDomain.name == item.name;
                        },
                        this
                    );
                    if (configuredDomainObj) {
                        const obj = {};
                        obj.id = item.name;
                        obj.title = item.properties?.externalName ? item.properties.externalName : item.name;
                        obj.value = obj.title;
                        obj.hasClassifications = configuredDomainObj.hasClassifications
                            ? configuredDomainObj.hasClassifications
                            : false;
                        obj.classificationAttributeName = configuredDomainObj.classificationAttributeName
                            ? configuredDomainObj.classificationAttributeName
                            : 'rootexternalname';
                        obj.type = configuredDomainObj.type ? configuredDomainObj.type : item.name;
                        obj.hierarchicalColId = configuredDomainObj.hierarchicalColId
                            ? configuredDomainObj.hierarchicalColId
                            : '';
                        obj.manageModelName = configuredDomainObj.manageModelName
                            ? configuredDomainObj.manageModelName
                            : false;
                        if (item.name == defaultDomain) {
                            this._setSelectedDomain(obj);
                        }
                        domains.push(obj);
                    }
                }, this);
                this._domainList = domains;
                this._isDomainLovPrepared = true;
            } else {
                LoggerManager.logError(this, 'Failed to fetch domains', domainResponse);
            }
            this._loading = false;
        }
    }

    /**
     * Function to populate the selected and _previousSelected domain (to be used in dirtycheck)
     */
    _setSelectedDomain(obj) {
        if (!ObjectUtils.isEmpty(obj)) {
            this._selectedDomain = obj;
            this._previousSelectedDomain = this._createLovSelectedTemplateObj(obj);
            if (this.domainLov && !ObjectUtils.isEmpty(this.domainLov.tagValues)) {
                this._previousSelectedDomain.tagValues = this.domainLov.tagValues;
            }
        }
    }

    /**
     * Function to create a template of selected obj of the LOVs from the given obj
     */
    _createLovSelectedTemplateObj(obj) {
        let _lovSelObjTemplate = {};
        if (!ObjectUtils.isEmpty(obj) && obj.title) {
            _lovSelObjTemplate.item = obj;
            _lovSelObjTemplate.title = obj.title;
            _lovSelObjTemplate.tagValues = [
                {
                    longName: obj.title,
                    name: obj.title,
                    tagValue: obj.title
                }
            ];
        }
        return _lovSelObjTemplate;
    }

    /**
     * Function to populate the source/target dropdown
     */
    async _prepareSources(defaultSource) {
        this._loading = true;
        this._sourceList = [];
        this._selectedSource = {};
        let sourceList = [];
        if (this._selectedDomain) {
            if (this._selectedDomain.hasClassifications) {
                let clonedContextData = ObjectUtils.cloneObject(this.contextData);
                clonedContextData[ContextUtils.CONTEXT_TYPE_ITEM] = [{ type: this._selectedDomain.type }];
                let request = DataRequestHelper.createEntityGetRequest(clonedContextData, true);
                delete request.params.query.id;
                delete request.params.fields.relationshipAttributes;
                delete request.params.fields.relationships;
                //Update attributes, type and ids
                request.params.fields.attributes = ['externalName'];
                let getRequest = DataObjectManager.createRequest('searchandget', request, '', {});
                let getResponse = await DataObjectManager.initiateRequest(getRequest);
                if (getResponse && getResponse.response && getResponse.response.status == 'success') {
                    let entities = getResponse.response?.content?.entities;
                    if (entities) {
                        entities.forEach(function (entity) {
                            let obj = {};
                            let externalName = AttributeUtils.getFirstAttributeValue(
                                entity.data.attributes['externalName']
                            );
                            (obj.id = entity.name), (obj.title = externalName ? externalName : entity.name);
                            obj.value = externalName ? externalName : entity.name;
                            //Set the selected source
                            if (defaultSource && entity.name === defaultSource) {
                                this._setSelectedSource(obj);
                            }
                            sourceList.push(obj);
                        }, this);
                    }
                }
            } else {
                let sources = await EntityTypeManager.getEntityTypesByDomain(this._selectedDomain.id);
                for (const entityType of sources) {
                    let entityTypeExternalName = EntityTypeManager.getTypeExternalNameById(entityType);
                    let obj = {};
                    (obj.id = entityType),
                        (obj.title = entityTypeExternalName ? entityTypeExternalName : entityType),
                        (obj.value = entityTypeExternalName ? entityTypeExternalName : entityType);
                    sourceList.push(obj);
                    //Set the selected source
                    if (defaultSource && entityType === defaultSource) {
                        this._setSelectedSource(obj);
                    }
                }
            }
        } else {
            LoggerManager.info('No selected domain');
        }

        //Reset the tags if no source is selected
        if (this.sourceLov && ObjectUtils.isEmpty(this._selectedSource)) {
            //TODO : Need to remove below 2 lines in future after the bedrock-lov PR on clearValues is merged
            this.sourceLov._lovSelectedItem = Constants.NULL_VALUE;
            this.sourceLov.selectedValue = Constants.NULL_VALUE;
            this.sourceLov.clearValues();
        }
        this._sourceList = sourceList;
        this._isSourceLovPrepared = true;
        this._loading = false;
    }

    /**
     * Function to populate the selected and _previousSelected source/target (to be used in dirtycheck)
     */
    _setSelectedSource(obj) {
        if (!ObjectUtils.isEmpty(obj)) {
            this._selectedSource = obj;
            this._previousSelectedSource = this._createLovSelectedTemplateObj(obj);
            if (this.sourceLov && !ObjectUtils.isEmpty(this.sourceLov.tagValues)) {
                this._previousSelectedSource.tagValues = this.sourceLov.tagValues;
            }
        }
    }

    /**
     * Function to populate the relationship dropdown
     */
    async _prepareRelationshipTypes(defaultRelationshipType) {
        this._loading = true;
        this._relationshipTypes = [];
        this._selectedRelationship = {};
        //Reset the previous relationship lov selection
        if (this.relationshipLov) {
            //TODO : Need to remove below 2 lines in future after the bedrock-lov PR on clearValues is merged
            this.relationshipLov._lovSelectedItem = Constants.NULL_VALUE;
            this.relationshipLov.selectedValue = Constants.NULL_VALUE;
            this.relationshipLov.clearValues();
        }
        let clonedContextData = ObjectUtils.cloneObject(this.contextData);
        let type = this._selectedSource?.id;
        if (type) {
            let itemContext = {};
            itemContext.type = type;
            itemContext.relationships = ['_ALL'];
            itemContext.relationshipAttributes = ['_ALL'];
            clonedContextData[ContextUtils.CONTEXT_TYPE_ITEM] = [itemContext];

            if (this._selectedDomain) {
                clonedContextData[ContextUtils.CONTEXT_TYPE_DOMAIN] = [{ domain: this._selectedDomain.id }];
            }
            let compositeModelGetRequest = DataRequestHelper.createEntityModelCompositeGetRequest(clonedContextData);

            delete compositeModelGetRequest.params.query.name;
            compositeModelGetRequest.params.query.id = type + '_entityCompositeModel';
            let compositeModel = await EntityCompositeModelManager.getCompositeModel(
                compositeModelGetRequest,
                clonedContextData
            );
            if (compositeModel && compositeModel.data) {
                let relationshipModels = DataTransformHelper.transformRelationshipModels(
                    compositeModel,
                    clonedContextData
                );

                let defaultRelationshipObj = {};
                let rels = [];
                let currentItem = relationshipModels;
                if (currentItem) {
                    let relTypes = Object.keys(currentItem);
                    if (relTypes && relTypes.length > 0) {
                        for (let j = 0; j < relTypes.length; j++) {
                            let relType = relTypes[j];
                            let rel = currentItem[relType];
                            if (rel && rel.length > 0) {
                                for (let k = 0; k < rel.length; k++) {
                                    if (rel[k].id) {
                                        if (rel[k].properties && rel[k].properties.relatedEntityInfo) {
                                            let externalName =
                                                rel[k].properties && rel[k].properties.externalName
                                                    ? rel[k].properties.externalName
                                                    : rel[k].id;
                                            let newItem = {
                                                id: rel[k].id,
                                                relationshipName: relType,
                                                title: externalName,
                                                value: externalName,
                                                relEntityTypes: rel[k].properties.relatedEntityInfo.map(
                                                    relEntityInfo => {
                                                        return relEntityInfo.relEntityType;
                                                    }
                                                ),
                                                attributes: rel[k].attributes,
                                                relationshipOwnership: rel[k].properties.relationshipOwnership
                                            };
                                            if (defaultRelationshipType == relType) {
                                                defaultRelationshipObj = newItem;
                                            }
                                            rels.push(newItem);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (!ObjectUtils.isEmpty(defaultRelationshipObj)) {
                    this._setSelectedRelationship(defaultRelationshipObj);
                }
                this._isRelationshipLovPrepared = true;
                this._relationshipTypes = rels;
            } else {
                LoggerManager.info('relationships not found');
            }
        } else {
            LoggerManager.info('source not found');
        }
        this._loading = false;
    }

    /**
     * Function to populate the selected and _previousSelected source/target (to be used in dirtycheck)
     */
    _setSelectedRelationship(obj) {
        this._selectedRelationship = {};
        if (!ObjectUtils.isEmpty(obj)) {
            this._selectedRelationship = obj;
            this._previousSelectedRel = this._createLovSelectedTemplateObj(obj);
            if (this.relationshipLov && !ObjectUtils.isEmpty(this.relationshipLov.tagValues)) {
                this._previousSelectedRel.tagValues = this.relationshipLov.tagValues;
            }
        }
    }

    /**
     * Function to handle domain change
     */
    async _onDomainChange(e) {
        if (!this._isDirtyCheckHandled) {
            let isDirty = this._performDirtyCheck('domainChange');
            if (isDirty) {
                return;
            }
        }

        this._selectedDomain = {};
        if (e && e.detail) {
            this._selectedDomain = _.find(this._domainList, function (item) {
                return item.title == e.detail;
            });
        }

        //Reset the Source and Relationship LOV
        await this._prepareSources();
        await this._prepareRelationshipTypes();

        this._setSelectedDomain(this._selectedDomain);

        //Reload the grid
        this._reloadGridConfig();
    }

    /**
     * Function to handle source/target change
     */
    async _onSourceChange(e) {
        if (!this._isDirtyCheckHandled) {
            let isDirty = this._performDirtyCheck('sourceChange');
            if (isDirty) {
                return;
            }
        }

        this._selectedSource = {};
        if (e && e.detail) {
            this._selectedSource = _.find(this._sourceList, function (item) {
                return item.title == e.detail;
            });
        }

        //Reset the Relationship LOV
        await this._prepareRelationshipTypes();

        this._setSelectedSource(this._selectedSource);

        //Reload the grid
        this._reloadGridConfig();
    }

    /**
     * Function to handle relationship change
     */
    _onRelationshipTypeChange(e) {
        if (!this._isDirtyCheckHandled) {
            let isDirty = this._performDirtyCheck('relationshipChange');
            if (isDirty) {
                return;
            }
        }

        if (e && e.detail) {
            let _selectedRelationship = _.find(this._relationshipTypes, function (item) {
                return item.title == e.detail;
            });
            this._setSelectedRelationship(_selectedRelationship);
        }

        //Reload the grid
        this._onInitialLoad();
    }

    /**
     * Function to fetch rock-drag-drop-grid based on given domain and source
     */
    _reloadGridConfig() {
        this._actionScope = {};
        let clonedContextData = this._getUserSelectedContextData();
        this._actionScope.contextData = clonedContextData;
        this._actionScope.scopeId = this.scopeId;
        //Fetch the grid config and merge with config
        this.requestConfig('rock-drag-drop-grid', clonedContextData);
    }

    /**
     * Function to user selected context info including domain/item and value context
     */
    _getUserSelectedContextData() {
        let domain = this._selectedDomain ? this._selectedDomain.id : '';
        let source = this._selectedSource ? this._selectedSource.id : '';

        let clonedContextData = ObjectUtils.cloneObject(this.contextData);
        if (!ObjectUtils.isEmpty(domain)) {
            clonedContextData[ContextUtils.CONTEXT_TYPE_DOMAIN] = [{ domain: domain }];
        }
        if (!ObjectUtils.isEmpty(source)) {
            clonedContextData[ContextUtils.CONTEXT_TYPE_ITEM] = [{ type: source }];
        }

        clonedContextData[ContextUtils.CONTEXT_TYPE_VALUE] = [DALCommonUtils.getDefaultValContext()];

        return clonedContextData;
    }

    /**
     * Function to update the grid's item config based on user selected context data
     */
    onConfigLoaded(componentConfig) {
        if (componentConfig) {
            //Update the column names from source/target
            if (
                ObjectUtils.isValidObjectPath(componentConfig, 'config.' + this.configType + '.gridConfig.itemConfig')
            ) {
                let itemConfig = componentConfig.config[this.configType].gridConfig.itemConfig;
                if (this.config && itemConfig) {
                    this.config.gridConfig.itemConfig = itemConfig;
                }
            }
        }
        this._onInitialLoad();
    }

    listen(node, eventName, handler) {
        node.addEventListener(eventName, handler);
    }

    unlisten(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
    }

    /**
     * Populate the gridoptions & actioncallbacks based on the configurations
     */
    _treeTypeChanged() {
        if (this.config && this.config.treeType) {
            if (this.config.treeType == 'flat') {
                let flatOptions = {
                    rowDragManaged: false,
                    rowSelection: this.rowSelection,
                    animateRows: true,
                    getRowId: params => {
                        return params.data.id;
                    }
                };
                let _gridOptions = this.options ? this.options : {};
                for (let prop in flatOptions) {
                    _gridOptions[prop] = flatOptions[prop];
                }
                this._gridOptions = _gridOptions;
            } else if (this.config.treeType == 'hierarchical') {
                let hierarchicalOptions = {
                    defaultColDef: {
                        flex: 1,
                        resizable: true
                    },
                    treeData: true,
                    animateRows: true,
                    groupDefaultExpanded: -1,
                    getRowStyle: params => {
                        if (params.node?.data?.changedDragInfo?.[params.node.hierarchyId]?.dragged) {
                            return { background: '#eaf3fc' };
                        }
                    },
                    getDataPath: data => {
                        return data.filePath;
                    },
                    getRowId: params => {
                        return params.data.id;
                    },
                    autoGroupColumnDef: {
                        rowDrag: true,
                        headerName: 'Tree',
                        floatingFilter: true,
                        floatingFilterComponentParams: { suppressFilterButton: true },
                        filter: 'agTextColumnFilter',
                        minWidth: 300
                    },
                    onRowDragEnd: this.onRowDragEnd
                };
                let _gridOptions = this.options ? this.options : {};
                for (let prop in hierarchicalOptions) {
                    _gridOptions[prop] = hierarchicalOptions[prop];
                }
                this._gridOptions = _gridOptions;
            }
        }
    }

    /*_optionsChanged() {
		if (!ObjectUtils.isEmpty(this.options)) {
			let _gridOptions = this.options ? this.options : {};
			for (let prop in this._gridOptions) {
				_gridOptions[prop] = this._gridOptions[prop];
			}
			this._gridOptions = _gridOptions;
		}
	}*/

    /**
     * Function to fetch attributemodels and load the grid data
     */
    async _onInitialLoad() {
        this.attributeModels = {};
        if (!ObjectUtils.isEmpty(this.config)) {
            this._gridConfig = this.config?.gridConfig;
            let attributeNames = this._getAttributeNamesFromConfig();
            this.attributeModels = await this._getAttributeModels(attributeNames);
            this._setColumns();
            this._loadGrid();
        }
    }

    /**
     * Function to fetch attribute names from the grid config
     */
    _getAttributeNamesFromConfig() {
        let attributeNames = [];
        //Get the Source/Target
        if (ObjectUtils.isValidObjectPath(this.config, 'gridConfig.itemConfig.fields')) {
            let _fields = ObjectUtils.convertToArray(this.config.gridConfig.itemConfig.fields);
            attributeNames = _fields.map(item => item.name);
        }
        return attributeNames;
    }

    /**
     * Function to fetch attributemodels
     */
    async _getAttributeModels(attributeNames) {
        if (!ObjectUtils.isEmpty(attributeNames)) {
            let clonedContextData = this._getUserSelectedContextData();
            if (!clonedContextData[ContextUtils.CONTEXT_TYPE_ITEM]) {
                clonedContextData[ContextUtils.CONTEXT_TYPE_ITEM] = [{}];
            }
            clonedContextData[ContextUtils.CONTEXT_TYPE_ITEM][0].attributeNames = attributeNames;
            if (this._selectedDomain?.manageModelName) {
                clonedContextData[ContextUtils.CONTEXT_TYPE_ITEM][0].type = this._selectedDomain.manageModelName;
            }
            let compositeModelGetRequest = DataRequestHelper.createEntityModelCompositeGetRequest(clonedContextData);
            let compositeModel = await EntityCompositeModelManager.getCompositeModel(
                compositeModelGetRequest,
                clonedContextData
            );
            if (compositeModel && compositeModel.data) {
                return DataTransformHelper.transformAttributeModels(compositeModel, clonedContextData);
            }
        }

        return {};
    }

    /**
     * Function to set/sort grid columns
     */
    async _setColumns() {
        let itemConfig = this.config.gridConfig.itemConfig;
        let columns = [];
        let fields = itemConfig ? itemConfig.fields : undefined;
        let defaultSort = itemConfig && itemConfig.sort ? itemConfig.sort.default : undefined;
        if (fields) {
            for (let fieldKey in fields) {
                let field = fields[fieldKey];
                if (field) {
                    this._updateColumns(field, columns, defaultSort);
                }
            }
            if (columns) {
                columns = _.sortBy(columns, function (item) {
                    return item.displaySequence;
                });
            }
        }
        if (this.config.treeType == 'flat') {
            columns[0].rowDrag = true;
        }
        this._columns = columns;
    }

    /**
     * Function to update grid columns
     */
    _updateColumns(field, columns, defaultSort) {
        if (field && field.name) {
            let headerName =
                this.attributeModels[field.name] && this.attributeModels[field.name].externalName
                    ? this.attributeModels[field.name].externalName
                    : field.name;
            let column = {
                headerName: field.header ? field.header : headerName,
                field: field.name,
                tooltipField: field.iconColumn ? '' : field.name,
                headerTooltip: field.header,
                isMetaDataColumn: field.isMetaDataColumn,
                sortable: field.sortable,
                width: field.width,
                icon: field.icon,
                iconTooltip: field.iconTooltip,
                filterable: field.filterable || this.config.gridConfig.bulkEditMode,
                displaySequence: field.displaySequence,
                displayType: field.displayType,
                iconColumn: field.iconColumn,
                linkTemplate: field.linkTemplate,
                headerDescription: this._extractHeaderDescription(field),
                gridColDef: {},
                attrModel: {},
                pinned: field.pinned
            };

            //Default sort
            if (!ObjectUtils.isEmpty(defaultSort)) {
                let sortOption = defaultSort.find(v => v.field == field.name);
                if (!ObjectUtils.isEmpty(sortOption)) {
                    column.sort = sortOption.sortType;
                }
            }
            if (field.isLinkColumn && field.linkTemplate) {
                column.cellRenderer = 'pebbleGridLinkCell';
                column.cellRendererParams = params => {
                    return {
                        params: params
                    };
                };
            }

            if (field.hide) {
                column.hide = true;
            }

            columns.push(column);
        }
    }

    /**
     * Function to extract header desc
     */
    _extractHeaderDescription(attributeModel) {
        let descriptionObject = {};
        if (attributeModel && attributeModel.properties) {
            descriptionObject.description = attributeModel.properties.description;
        }
        return descriptionObject;
    }

    /**
     * Function to prepare data request and set datasource
     */
    async _loadGrid() {
        let clonedContextData = this._getUserSelectedContextData();
        if (ObjectUtils.isValidObjectPath(clonedContextData, ContextUtils.CONTEXT_TYPE_ITEM + '.0')) {
            let attributeNames = this._getAttributeNamesFromConfig();
            clonedContextData[ContextUtils.CONTEXT_TYPE_ITEM][0].attributeNames = attributeNames;
        }
        if (!ObjectUtils.isEmpty(clonedContextData) && !ObjectUtils.isEmpty(this._columns)) {
            this._prepareEntityRequest(clonedContextData);
            //If _entityDataGetReq is not prepared, then show empty grid
            if (ObjectUtils.isEmpty(this._entityDataGetReq)) {
                this._showEmptyGrid();
                return;
            }
            this._setGridDataSource(this._columns);
        }
    }

    /**
     * Function to prepare entity get request
     */
    _prepareEntityRequest(contextData) {
        if (!ObjectUtils.isEmpty(contextData)) {
            this._entityDataGetReq = DataRequestHelper.createEntityGetRequest(contextData);

            if (!ObjectUtils.isEmpty(this._entityDataGetReq)) {
                //Build the attributesCriterion for source/target dropdown
                if (!ObjectUtils.isEmpty(this._selectedDomain)) {
                    if (
                        ObjectUtils.isValidObjectPath(this._entityDataGetReq, 'params.query.filters.typesCriterion') &&
                        this._selectedDomain.manageModelName
                    ) {
                        this._entityDataGetReq.params.query.filters.typesCriterion = [
                            this._selectedDomain.manageModelName
                        ];
                    }

                    if (this._selectedDomain.hasClassifications && !ObjectUtils.isEmpty(this._selectedSource)) {
                        let _attributesCriterionObj = {};
                        _attributesCriterionObj[this._selectedDomain.classificationAttributeName] = {
                            exact: this._selectedSource.id,
                            type: '_STRING'
                        };
                        this._entityDataGetReq.params.query.filters.attributesCriterion = [_attributesCriterionObj];
                    }
                }

                //Build the relationshipsCriterion for relationship dropdown
                if (!ObjectUtils.isEmpty(this._selectedRelationship)) {
                    let _relationshipsCriterionObj = {};
                    _relationshipsCriterionObj[this._selectedRelationship.relationshipName] = {
                        relTo: {
                            type: this._selectedRelationship.relEntityTypes[0]
                        }
                    };

                    this._entityDataGetReq.params.query.filters.relationshipsCriterion = [_relationshipsCriterionObj];
                }

                //Build the keywordCriterion for searchbar input
                if (this.searchBar && !ObjectUtils.isEmpty(this.searchBar.query)) {
                    let searchQuery = this.searchBar.query;
                    let searchCriteria = DataHelper.getSearchCriteria(searchQuery);
                    let keywordsCriterion = {};
                    keywordsCriterion.keywords = searchCriteria.keywords;
                    keywordsCriterion.operator = '_AND';
                    this._entityDataGetReq.params.query.filters.keywordsCriterion = keywordsCriterion;
                }
            }
        }
    }

    /**
     * Function to set grid datasource
     */
    async _setGridDataSource() {
        if (this.grid) {
            let responseFormatter = data => {
                return this._getAttributeFormattedData(data);
            };

            let cb = () => {
                this._updateGridInfo();
                this.invalidateCache = false;
            };

            let dataSourceParams = {
                request: this._entityDataGetReq,
                pageSize: this.pageSize,
                batchSize: this.batchSize,
                isCombinedGetReq: false,
                dataIndex: this._dataIndex
            };

            let _dataSource = new EntityGridDataSource(dataSourceParams);
            let clonedContextData = this._getUserSelectedContextData();
            let requestHandler = async requestOptions => {
                if (this.maxConfiguredCount) {
                    requestOptions.maxRecords = this.maxConfiguredCount;
                }
                let responseData = await _dataSource.requestHandler(
                    requestOptions,
                    this.attributeModels,
                    clonedContextData,
                    this.config.gridConfig,
                    this.invalidateCache
                );
                if (responseData.status == 'success') {
                    return responseData;
                } else {
                    LoggerManager.logError(this, 'Failed to fetch search results for the given criteria', responseData);
                    this._showEmptyGrid();
                    return [];
                }
            };

            if (this.configType == 'source') {
                //Fetching source grid data dynamically lazy loaded
                this.grid.dataSource = new BedrockGridDataSource(
                    requestHandler,
                    responseFormatter,
                    this.pageSize,
                    this.maxConfiguredCount,
                    cb
                );
                this.isGridDataEmpty = false;
            } else {
                //Making the target client side model
                let params = {
                    startRow: 0,
                    endRow: this.pageSize ? this.pageSize - 1 : this.pageSize,
                    clientSideModel: true
                };

                let bedrockGridData = new BedrockGridDataSource(requestHandler, responseFormatter);
                let items = await bedrockGridData.getData(params);
                let grid = this.shadowRoot.querySelector('bedrock-grid');
                grid.items = items;
            }
        }
    }

    /**
     * Function to dynamically update the grid items count
     */
    _updateGridInfo() {
        if (this.grid) {
            this.currentRecordSize = 0;
            this.currentRecordSize = this.grid.dataSource.currentRecordSize;
        }
    }

    /**
     * Function to format data
     */
    async _getAttributeFormattedData(data) {
        let formattedEntities = [];
        let clonedContextData = this._getUserSelectedContextData();
        //let defaultAttributes = ['type', 'id'];
        //let thumbnailIdFound = false;
        if (data && data.content) {
            this.resultRecordSize = data.resultRecordSize != undefined ? data.resultRecordSize : this.resultRecordSize;
            //this.initSearchEntityIds = data.initSearchEntityIds ? data.initSearchEntityIds : [];
            let entities;
            if (data.content.entities) {
                entities = data.content.entities;
            } else if (data.content.entityModels) {
                entities = data.content.entityModels;
            }
            if (entities && entities.length > 0) {
                formattedEntities = await DataTransformHelper.transformEntitiesToGridFormat(
                    entities,
                    this.attributeModels,
                    clonedContextData,
                    this._getGridColumns(this.config.gridConfig),
                    true,
                    'grid'
                );
                /* for (let i = 0; i < formattedEntities.length; i++) {
                        let imageObj = EntityUtils.getEntityImageObject(
                            formattedEntities[i],
                            this._previewAssetAttribute,
                            clonedContextData
                        );
                        if (!ObjectUtils.isEmpty(imageObj)) {
                            if (imageObj.value) {
                                thumbnailIdFound = true;
                                break;
                            }
                        }
                    }*/
            } else {
                this._showEmptyGrid();
            }
        }

        return this.transformData(this._columns, formattedEntities);
    }

    /**
     * Function to show empty grid
     */
    _showEmptyGrid() {
        if (this.grid) {
            this.grid.items = [];
        }
        this.grid.dataSource = {};
        this.resultRecordSize = 0;
        this.currentRecordSize = 0;
        this._isGridDataEmpty = true;
        this._gridInfo = this.localize('NoResMsg');
        this._loading = false;
    }

    /**
     * Function to get grid columns
     */
    _getGridColumns(gridConfig) {
        if (gridConfig && gridConfig.tabular && gridConfig.tabular.columns) {
            return this.config.gridConfig.tabular.columns;
        }
        let columns = [];
        if (ObjectUtils.isValidObjectPath(gridConfig, 'itemConfig.fields')) {
            columns = ObjectUtils.convertToArray(gridConfig.itemConfig.fields);
        }
        return columns;
    }

    /**
     * Function to transform data into drag drop grid format
     */
    transformData(columns, entities) {
        let data = [];
        let clonedContextData = this._getUserSelectedContextData();
        if (!ObjectUtils.isEmpty(columns)) {
            for (let entity of entities) {
                let attributes = entity.attributes;
                if (attributes) {
                    let rowData = {};
                    rowData.id = entity.id;
                    rowData.type = entity.type;
                    rowData.typeExternalName = entity.typeExternalName;
                    rowData.name = entity.name;
                    let attrModels = this.attributeModels;
                    let firstDataContext = ContextUtils.getFirstDataContext(clonedContextData);
                    let entityAttributes = EntityUtils.getAttributesBasedOnContext(entity, firstDataContext);
                    let attributeObj = attributes[firstDataContext] ? attributes[firstDataContext] : {};
                    for (let column of columns) {
                        let colId = column.field;
                        let colFieldName = column.field ? column.field : '';
                        let attrModel = attrModels && attrModels[colId];
                        let filePath = [];
                        let filePathInString = '';
                        let _isPathExist = false;
                        if (ObjectUtils.isEmpty(attrModel)) {
                            attrModel = attrModels[colFieldName];
                        }
                        if (!ObjectUtils.isEmpty(attrModels) && !ObjectUtils.isEmpty(attrModels[colFieldName])) {
                            attrModels[colId] = attrModels[colFieldName];
                            let attributeModel = attrModels[colId];
                            if (!ObjectUtils.isEmpty(attributeModel)) {
                                attributeObj = attributes[colFieldName] ? attributes[colFieldName] : {};
                                let attributeValue = attributeModel.isCollection ? [] : '';
                                if (
                                    !ObjectUtils.isEmpty(attributeObj) &&
                                    ObjectUtils.isValidObjectPath(entityAttributes, `${colFieldName}.values`)
                                ) {
                                    let valContexts = ContextUtils.getValueContexts(clonedContextData);
                                    valContexts[0].locale = column.locale;
                                    let attributeValues = AttributeUtils.getAttributeValues(
                                        entityAttributes[colFieldName].values,
                                        valContexts[0]
                                    );
                                    attributeValue = attributeModel.isCollection ? attributeValues : attributeValues[0];
                                }
                                if (
                                    ObjectUtils.isValidObjectPath(this._selectedDomain, 'hierarchicalColId') &&
                                    colId == this._selectedDomain.hierarchicalColId &&
                                    this.config.treeType == 'hierarchical'
                                ) {
                                    filePathInString = attributeValue;
                                    filePath = attributeValue.split('>>');
                                    _isPathExist = true;
                                }
                                attributes[colId] = {
                                    ...attributeObj,
                                    value: attributeValue,
                                    locale: column.locale
                                };
                            }
                        }
                        rowData[colId] = attributes[colId] ? attributes[colId].value : '';
                        //TODO : handle the entities that does not have path
                        if (_isPathExist) {
                            let previousFilePathStrings = data.map(item => item.filePathInString);
                            let newRows = this.createHierarchicalData(filePathInString, previousFilePathStrings);
                            data = [...data, ...newRows];
                            rowData['filePathInString'] = filePathInString;
                            rowData['filePath'] = filePath;
                            rowData['type'] = 'file';
                        }
                    }
                    data.push(rowData);
                }
            }
        }
        this.originalData = ObjectUtils.cloneObject(data);
        return data;
    }

    _onSearch() {
        if (!this._isDirtyCheckHandled) {
            let isDirty = this._performDirtyCheck('search');
            if (isDirty) {
                return;
            }
        }

        if (this.searchBar && !ObjectUtils.isEmpty(this.searchBar.query)) {
            this._previousSearchedQuery = this.searchBar.query;
        }

        this._loadGrid();
    }

    /**
     * Function to refresh the target grid data (clientside data)
     */
    _onRefreshTarget(detail) {
        //Ignore unrelated events
        if (detail && detail.scopeId != this.scopeId) return;

        if (!this._isDirtyCheckHandled) {
            let isDirty = this._performDirtyCheck('refresh');
            if (isDirty) {
                return;
            }
        }

        if (this.grid && this.configType == 'target') {
            this.grid.items = ObjectUtils.cloneObject(this.originalData);
        }
    }

    /**
     * Function to refresh the source grid data
     */
    _onRefreshSource(detail) {
        //Ignore unrelated events
        if (detail && detail.scopeId != this.scopeId) return;

        if (this.grid) {
            this.grid.reRenderGrid();
        }
    }

    /**
     * Function to save the updated grid data
     */
    _onSaveGridData() {
        //let changedData = this.getChangedTreeData();
        //TODO: Code updates for Save
        //console.log("Save Grid Data : " + JSON.stringify(changedData));
    }

    /**
     * Function to handle showMapped toggle click
     */
    _onShowMappedChange(e) {
        let toggleState = e.detail?.value;
        this._isShowMapped = toggleState;
    }

    /**
     * Function to check if the page is dirty
     */
    getIsDirty() {
        let changedData = this.getChangedTreeData();
        //TODO : Can be removed if undefined is not rendered in changedData
        changedData = changedData.filter(function (item) {
            return item !== undefined;
        });
        return !ObjectUtils.isEmpty(changedData) ? true : false;
    }

    /**
     * Function to show dirtyCheck dialog
     */
    _performDirtyCheck(eventName) {
        //Dirty check on target grid
        if (this.configType == 'target') {
            let isDirty = this.getIsDirty();
            if (isDirty) {
                this._dirtyCheckEventName = eventName;
                DialogManager.openConfirm(this, this.localize('DisChaWar'));
            }
            return isDirty;
        }

        return false;
    }

    /**
     * Function to handle dirtyCheck confirmation
     */
    confirmDialogHandler(confirmStatus) {
        let e = { detail: '' };
        this._isDirtyCheckHandled = true;
        if (confirmStatus) {
            if (this._dirtyCheckEventName == 'search') {
                this._onSearch();
            } else if (this._dirtyCheckEventName == 'refresh') {
                this.configType == 'target' ? this._onRefreshTarget() : this._onRefreshSource();
            } else if (this._dirtyCheckEventName == 'domainChange' && this.domainLov) {
                e.detail = this.domainLov.selectedValue;
                this._onDomainChange(e);
            } else if (this._dirtyCheckEventName == 'sourceChange' && this.sourceLov) {
                e.detail = this.sourceLov.selectedValue;
                this._onSourceChange(e);
            } else if (this._dirtyCheckEventName == 'relationshipChange' && this.relationshipLov) {
                e.detail = this.relationshipLov.selectedValue;
                this._onRelationshipTypeChange(e);
            }
        } else {
            if (this._dirtyCheckEventName == 'search') {
                this.searchBar.searchText = this._previousSearchedQuery;
                this.searchBar.query = this._previousSearchedQuery;
            } else if (
                this._dirtyCheckEventName == 'domainChange' &&
                !ObjectUtils.isEmpty(this._previousSelectedDomain)
            ) {
                this.domainLov._lovSelectedItem = this._previousSelectedDomain?.item;
                this.domainLov.selectedValue = this._previousSelectedDomain?.title;
                this.domainLov.tagValues = this._previousSelectedDomain?.tagValues;
            } else if (
                this._dirtyCheckEventName == 'sourceChange' &&
                !ObjectUtils.isEmpty(this._previousSelectedSource)
            ) {
                this.sourceLov._lovSelectedItem = this._previousSelectedSource?.item;
                this.sourceLov.selectedValue = this._previousSelectedSource?.title;
                this.sourceLov.tagValues = this._previousSelectedSource?.tagValues;
            } else if (
                this._dirtyCheckEventName == 'relationshipChange' &&
                !ObjectUtils.isEmpty(this._previousSelectedRel)
            ) {
                this.relationshipLov._lovSelectedItem = this._previousSelectedRel?.item;
                this.relationshipLov.selectedValue = this._previousSelectedRel?.title;
                this.relationshipLov.tagValues = this._previousSelectedRel?.tagValues;
            }
        }

        //Reset the flag
        this._isDirtyCheckHandled = false;
    }

    /**
     * Function to get the changed data
     */
    getChangedTreeData() {
        let rowModel = this.dragDropGrid._gridApi.getModel();
        let rootNode = rowModel.getRootNode();
        let treeData = rootNode.allLeafChildren.map(function (node) {
            if (node.data && node.data.changedDragInfo) {
                return node.data;
            }
        });
        return treeData;
    }

    _pebbleGridDataLoaded() {
        if (this.dragDropGrid && this.dragDropGrid._gridApi) {
            new CustomEvent('pebble-grid-data-loaded', {
                detail: {},
                bubbles: true,
                composed: true
            });
        }
    }

    /**
     * Drag drop grid functions
     */
    onRowDragEnd = event => {
        let overNode = event.overNode;

        if (!overNode) {
            return;
        }
        //let allIds = [];
        //this.dragDropGrid._gridApi.forEachNode(node => allIds.push(node.data.id));
        let issameGrid = event.node.groupData;

        // folder to drop into is where we are going to move the file/folder to
        let folderToDropInto =
            overNode.data.type === 'folder'
                ? // if over a folder, we take the immediate row
                  overNode
                : // if over a file, we take the parent row (which will be a folder)
                  overNode;

        // take new parent path from parent, if data is missing, means it's the root node,
        // which has no data.
        let newParentPath = folderToDropInto.data ? folderToDropInto.data.filePath : [];
        if (issameGrid) {
            // the data we want to move
            let movingData = event.node.data;

            let needToChangeParent = !this.arePathsEqual(newParentPath, movingData.filePath);

            // check we are not moving a folder into a child folder
            let invalidMode = this.isSelectionParentOfTarget(event.node, folderToDropInto);
            if (invalidMode) {
                LoggerManager.info('invalid move');
            }

            if (needToChangeParent && !invalidMode) {
                let updatedRows = [];
                this.moveToPath(newParentPath, event.node, updatedRows, issameGrid);

                this.dragDropGrid._gridApi.applyTransaction({
                    update: updatedRows
                });
                let updatedNode;
                let hierarchyIds = updatedRows.map(item => item.hierarchyId);
                this.dragDropGrid._gridApi.forEachNode(node => {
                    if (hierarchyIds.includes(node.data.hierarchyId)) {
                        updatedNode = node;
                        if (!node.data.changedDragInfo) {
                            node.data.changedDragInfo = {};
                        }
                        if (!node.data.changedDragInfo[node.hierarchyId]) {
                            node.data.changedDragInfo[node.hierarchyId] = {};
                        }
                        node.data.changedDragInfo[node.hierarchyId].dragged = true;
                    }
                });
                this.dragDropGrid._gridApi.redrawRows({
                    force: true,
                    node: [updatedNode]
                });
                //updatedNode.parent.setExpanded(false);
                //updatedNode.parent.setExpanded(true);
                //this.dragDropGrid._gridApi.collapseRow(updatedNode.parent);
                //gridOptions.api.expandRow(_updatedNode.parent);
            }
        } else {
            let updatedRows = [];
            this.moveToPath(newParentPath, event.node, updatedRows, issameGrid);
            console.log('Updated Rows' + updatedRows);
            this.dragDropGrid._gridApi.applyTransaction({
                add: updatedRows
            });
            //let addedRowNode;
            let updatedNode;
            let hierarchyIds = updatedRows.map(item => item.hierarchyId);
            this.dragDropGrid._gridApi.forEachNode(node => {
                if (hierarchyIds.includes(node.data.hierarchyId)) {
                    updatedNode = node;
                    if (!node.data.changedDragInfo) {
                        node.data.changedDragInfo = {};
                    }
                    if (!node.data.changedDragInfo[node.hierarchyId]) {
                        node.data.changedDragInfo[node.hierarchyId] = {};
                    }
                    node.data.changedDragInfo[node.hierarchyId].dragged = true;
                }
            });
            this.dragDropGrid._gridApi.redrawRows({
                force: true,
                rowNodes: [updatedNode]
            });
        }
    };
    moveToPath(newParentPath, node, allUpdatedNodes, issameGrid) {
        let oldPath = '';
        let fileName = '';
        if (node?.data?.filePath) {
            oldPath = node.data.filePath;
            fileName = oldPath[oldPath.length - 1];
        } else {
            oldPath = node.data['externalnamepath']?.split('>>');
        }
        //fileName = oldPath[oldPath.length - 1];
        let data = ObjectUtils.cloneObject(node.data);
        //let data = node.data;
        let newChildPath = newParentPath.slice();
        newChildPath.push(fileName || data['name']);
        data.filePath = newChildPath;
        node.data = data;
        if (issameGrid) {
            node.data.hierarchyId = node.hierarchyId = node.id;
        } else {
            node.data.hierarchyId = node.hierarchyId = UniqueIdUtils.getRandomId();
        }
        allUpdatedNodes.push(node.data);
        if (node.childrenAfterGroup) {
            node.childrenAfterGroup.forEach(childNode => {
                this.moveToPath(newChildPath, childNode, allUpdatedNodes, issameGrid);
            });
        }
    }

    dndMultipleItems(sourceSelectedItems, targetPath, issameGrid, targetGrid) {
        sourceSelectedItems.forEach(item => {
            let sourceData = {};
            sourceData.data = item;
            if (!ObjectUtils.isEmpty(sourceData))
                this.onMoveClick(targetPath, sourceData, false, targetGrid);
        });
    }

    onMoveClick(newParentPath, sourceData, issameGrid, targetGrid) {
        let updatedRows = [];
        this.moveToPath(newParentPath, sourceData, updatedRows, issameGrid);
        const bedrockGrid = targetGrid.shadowRoot.querySelector('bedrock-grid');
        const pebbleGrid = bedrockGrid.shadowRoot.querySelector('pebble-grid');
        pebbleGrid._gridApi.applyTransaction({
            add: updatedRows
        });
        let updatedNode;
        let hierarchyIds = updatedRows.map(item => item.hierarchyId);
        pebbleGrid._gridApi.forEachNode(node => {
            if (hierarchyIds.includes(node.data.hierarchyId)) {
                updatedNode = node;
                if (!node.data.changedDragInfo) {
                    node.data.changedDragInfo = {};
                }
                if (!node.data.changedDragInfo[node.hierarchyId]) {
                    node.data.changedDragInfo[node.hierarchyId] = {};
                }
                node.data.changedDragInfo[node.hierarchyId].dragged = true;
            }
        });
        pebbleGrid._gridApi.redrawRows({
            force: true,
            rowNodes: [updatedNode]
        });
    }

    isSelectionParentOfTarget(selectedNode, targetNode) {
        let children = [...(selectedNode.childrenAfterGroup || [])];

        if (!targetNode) {
            return false;
        }

        while (children.length) {
            const node = children.shift();
            if (!node) {
                continue;
            }

            if (node.key === targetNode.key) {
                return true;
            }

            if (node.childrenAfterGroup && node.childrenAfterGroup.length) {
                children.push(...node.childrenAfterGroup);
            }
        }

        return false;
    }
    arePathsEqual(path1, path2) {
        if (path1.length !== path2.length) {
            return false;
        }

        let equal = true;
        path1.forEach(function (item, index) {
            if (path2[index] !== item) {
                equal = false;
            }
        });

        return equal;
    }
    getGridAPi() {
        if (this.dragDropGrid && this.dragDropGrid._gridApi) {
            return this.dragDropGrid._gridApi;
        }
    }
    isFolderExistinPath(previousFilePathStrings, filePath) {
        let isFolderExist = false;
        previousFilePathStrings.forEach(currentItem => {
            //LoggerManager.info(currentItem);
            if (currentItem.includes(filePath)) {
                isFolderExist = true;
            }
        });
        return isFolderExist;
    }
    createHierarchicalData(inputPath, previousFilePathStrings) {
        const inputData = [];
        const pathParts = inputPath.split('>>').map(part => part.trim());
        let filePath = [];
        let filePathString = '';
        pathParts.forEach((part, index) => {
            if (index > 0) {
                filePathString += '>>';
            }
            filePathString += part;
            filePath.push(part);
            const type = index === pathParts.length - 1 ? 'file' : 'folder';
            let isFolderExist = this.isFolderExistinPath(previousFilePathStrings, filePathString);
            if (type == 'folder' && !isFolderExist) {
                inputData.push({
                    id: UniqueIdUtils.getRandomId(),
                    filePath: [...filePath],
                    filePathInString: filePathString,
                    type
                });
            }
        });
        return inputData;
    }
}

customElements.define('rock-drag-drop-grid', RockDragDropGrid);
